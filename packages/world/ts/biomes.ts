import type { Hex, PublicClient } from "viem";
import { voxelToChunkPos } from "./chunk";
import {
  bytecodeCache,
  getCacheKey,
  getChunkBytecode,
  readBytes1,
} from "./terrain";
import type { Vec3 } from "./vec3";

export const biomes = {
  badlands: 0,
  bamboo_jungle: 1,
  basalt_deltas: 2,
  beach: 3,
  birch_forest: 4,
  cherry_grove: 5,
  cold_ocean: 6,
  crimson_forest: 7,
  dark_forest: 8,
  deep_cold_ocean: 9,
  deep_dark: 10,
  deep_frozen_ocean: 11,
  deep_lukewarm_ocean: 12,
  deep_ocean: 13,
  desert: 14,
  dripstone_caves: 15,
  end_barrens: 16,
  end_highlands: 17,
  end_midlands: 18,
  eroded_badlands: 19,
  flower_forest: 20,
  forest: 21,
  frozen_ocean: 22,
  frozen_peaks: 23,
  frozen_river: 24,
  grove: 25,
  ice_spikes: 26,
  jagged_peaks: 27,
  jungle: 28,
  lukewarm_ocean: 29,
  lush_caves: 30,
  mangrove_swamp: 31,
  meadow: 32,
  mushroom_fields: 33,
  nether_wastes: 34,
  ocean: 35,
  old_growth_birch_forest: 36,
  old_growth_pine_taiga: 37,
  old_growth_spruce_taiga: 38,
  plains: 39,
  river: 40,
  savanna: 41,
  savanna_plateau: 42,
  small_end_islands: 43,
  snowy_beach: 44,
  snowy_plains: 45,
  snowy_slopes: 46,
  snowy_taiga: 47,
  soul_sand_valley: 48,
  sparse_jungle: 49,
  stony_peaks: 50,
  stony_shore: 51,
  sunflower_plains: 52,
  swamp: 53,
  taiga: 54,
  the_end: 55,
  the_void: 56,
  warm_ocean: 57,
  warped_forest: 58,
  windswept_forest: 59,
  windswept_gravelly_hills: 60,
  windswept_hills: 61,
  windswept_savanna: 62,
  wooded_badlands: 63,
  desert_canyon: 64,
  andesite_caves: 65,
  crystal_caves: 66,
  deep_caves: 67,
  desert_caves: 68,
  diorite_caves: 69,
  frostfire_caves: 70,
  fungal_caves: 71,
  granite_caves: 72,
  ice_caves: 73,
  infested_caves: 74,
  mantle_caves: 75,
  thermal_caves: 76,
  tuff_caves: 77,
  underground_jungle: 78,
  alpha_islands_winter: 79,
  alpha_islands: 80,
  alpine_grove: 81,
  alpine_highlands: 82,
  amethyst_canyon: 83,
  amethyst_rainforest: 84,
  ancient_sands: 85,
  arid_highlands: 86,
  ashen_savanna: 87,
  basalt_cliffs: 88,
  birch_taiga: 89,
  blooming_plateau: 90,
  blooming_valley: 91,
  brushland: 92,
  bryce_canyon: 93,
  caldera: 94,
  cloud_forest: 95,
  cold_shrubland: 96,
  desert_oasis: 97,
  desert_spires: 98,
  emerald_peaks: 99,
  forested_highlands: 100,
  fractured_savanna: 101,
  frozen_cliffs: 102,
  glacial_chasm: 103,
  granite_cliffs: 104,
  gravel_beach: 105,
  gravel_desert: 106,
  haze_mountain: 107,
  highlands: 108,
  hot_shrubland: 109,
  ice_marsh: 110,
  jungle_mountains: 111,
  lavender_forest: 112,
  lavender_valley: 113,
  lush_desert: 114,
  lush_valley: 115,
  mirage_isles: 116,
  moonlight_grove: 117,
  moonlight_valley: 118,
  mountain_steppe: 119,
  orchid_swamp: 120,
  painted_mountains: 121,
  red_oasis: 122,
  rocky_jungle: 123,
  rocky_mountains: 124,
  rocky_shrubland: 125,
  sakura_grove: 126,
  sakura_valley: 127,
  sandstone_valley: 128,
  savanna_badlands: 129,
  savanna_slopes: 130,
  scarlet_mountains: 131,
  shield_clearing: 132,
  shield: 133,
  shrubland: 134,
  siberian_grove: 135,
  siberian_taiga: 136,
  skylands_autumn: 137,
  skylands_spring: 138,
  skylands_summer: 139,
  skylands_winter: 140,
  skylands: 141,
  snowy_badlands: 142,
  snowy_cherry_grove: 143,
  snowy_maple_forest: 144,
  snowy_shield: 145,
  steppe: 146,
  stony_spires: 147,
  temperate_highlands: 148,
  tropical_jungle: 149,
  valley_clearing: 150,
  volcanic_crater: 151,
  volcanic_peaks: 152,
  warm_river: 153,
  warped_mesa: 154,
  white_cliffs: 155,
  white_mesa: 156,
  windswept_spires: 157,
  wintry_forest: 158,
  wintry_lowlands: 159,
  yellowstone: 160,
  yosemite_cliffs: 161,
  yosemite_lowlands: 162,
};

export const biomesById = Object.fromEntries(
  Object.entries(biomes).map(([name, id]) => [id, name]),
);

export async function getBiomeName(
  worldAddress: Hex,
  publicClient: PublicClient,
  [x, y, z]: Vec3,
): Promise<string> {
  const biome = await getBiome(worldAddress, publicClient, [x, y, z]);
  return biomesById[biome]!;
}

export async function getBiome(
  worldAddress: Hex,
  publicClient: PublicClient,
  [x, y, z]: Vec3,
): Promise<number> {
  const chunkCoord = voxelToChunkPos([x, y, z]);
  const cacheKey = getCacheKey(worldAddress, chunkCoord);

  let bytecode = bytecodeCache.get(cacheKey);
  if (!bytecode) {
    bytecode = await getChunkBytecode(publicClient, worldAddress, chunkCoord);
    bytecodeCache.set(cacheKey, bytecode);
  }

  return readBiome(bytecode);
}

export function readBiome(chunkBytecode: string): number {
  return readBytes1(chunkBytecode, 1);
}
